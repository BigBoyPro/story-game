# Manuel d'Exploitation


 ## Description du jeu :
- `Story Game` est un jeu web interactif conçu pour la création d'histoires en temps réel en groupe. 
Utilisant une architecture client-serveur, les utilisateurs peuvent créer des histoires en ajoutant, modifiant, 
et réorganisant des éléments narratifs tels que texte, images, et audio et même des dessins, permettant ainsi aux
utilisateurs d'exprimer leur créativité de manière collaborative, et de partager un bon moment entre amis.

## Technologies Utilisées :
- **Front-end:** `React`, `TypeScript`.
- **Back-end:** `Node.js`, `Express.js`, `TypeScript`.
- **Base de Données :** `Supabase` : BDD `PostgreSQL` en ligne.
- **Communication Client-Server :** `Socket.io`.
- **Outils de Développement :** `IntelliJ IDEA`, `WebStorm`, `Visual Studio Code`, `Supabase UI`, `Git`, `GitHub`.
- **Hébergement :** `Render` pour le back-end, `Vercel` pour le front-end.


## Setup :

### Sur le Site :
Le jeu est deja hébergé sur le site suivant : https://story-game.vercel.app/, vous pouvez y accéder et jouer à `Story Game` a
tout moment.

### Cloner le Projet :
Vous pouvez cloner le projet en utilisant la commande suivante :

    git clone https://github.com/BigBoyPro/story-game.git


### Installer les Dépendances:

Vous devez installer `nodejs` et `npm` depuis le site officiel : https://nodejs.org/en/download/current

Pour les utilisateurs de `IntelliJ IDEA` ou `WebStorm`: vous pouvez lancer le `Install` ou séparément `install client` et le `install server` en haut à droite pour que le code fonctionne

Sinon si ça ne fonctionne pas, vous pouvez aussi lancer les commandes suivantes depuis du repertoire racine du projet :

    cd client 
    npm install
    cd ..
    cd server
    npm install


## Pour lancer:
`IntelliJ IDEA` ou `WebStorm` :
- Vous pouvez directement lancer le client et le serveur en cliquant sur  `Run` en haut à droite.
- Vous pouvez lancer le client en cliquant sur `client dev` et le serveur en cliquant sur `server dev` en haut à droite.

Sinon, vous pouvez  lancer le client et le serveur avec les commandes suivantes depuis le repertoire racine du projet :
### Client:

    cd client
    npm run dev

### Serveur:

    cd server
    npm run dev



### Pour acceder a la base de donnees:
J'ai utilisé `Supabase` pour la base de donnees, c'est une BDD `PostgreSQL` en ligne,
pour y acceder, vous pouvez `creer un compte` sur le site suivant: https://supabase.com/dashboard/sign-in.  
Puis donnez-moi votre `mail` pour que je puisse vous inviter dans l'organisation `BIGSHELL`, pour que vous puissiez acceder a la base de donnees `story`.


Moi, j'utilise l'UI du [site de supabase](https://supabase.com/dashboard/project/nhldzevrwuqvytdltqgi/editor) pour creer les tables et tout...  
Mais si vous voulez utiliser autre chose, pour avoir `l'URL de Connection` a la base de donnees cliquer sur la bdd `story` pour aller sur le [Dashboard](https://supabase.com/dashboard/project/nhldzevrwuqvytdltqgi),
puis en haut à droite de la page, vous avez un bouton `Connect` qui va vous donner les differentes URL de connection.









## Architecture Technique :
#### Serveur : Le serveur est un serveur `Node.js` qui utilise `Express.js` 
  - Il envoie et reçoit des requêtes `Socket.io` de la part des clients, pour la gestion des lobbies (salles de jeu), des rounds,
    des histoires
  - Il communique en `PostgreSQL` avec la base de données `Supabase` pour stocker, récupérer et mettre à 
  jour les données.

#### Base de Données : La base de données est une base de données `PostgreSQL` hébergée en ligne par `Supabase`.
  - Tables: 
    - `users` : id, username, lobby_code, ready, last_active, created_at.
    - `lobbies` : code, host_user_id, round, users_submitted, round_start_at, round_end_at,
    current_story_index, current_user_index, user_index_order, created_at.  
    **paramètres =>** max_players, see_prev_story_part,
    with_text_to_speech, max_texts, max_images, max_audios, max_drawings, timer_setting, round_seconds.
    - `stories`: id, index, lobby_code, name, created_at.
    - `story_elements`: id, index, story_id, user_id, round, type, content, created_at.


#### Client : Le client est une application web `React`.
  - Il envoie les requêtes `Socket.io` au serveur contenant les actions des utilisateurs, comme créer un lobby, changer 
  les paramètres d'un lobby, ajouter un élément à l'histoire, etc.
  - Il reçoit les réponses du serveur et met à jour l'interface utilisateur en conséquence.




## Structure du Projet :
#### `/shared/sharedTypes.ts`: contient les types partagés entre le client et le serveur :
- nous avons rassemblé tous les types, les fonctions et les constantes partagés entre le client et le serveur dans ce fichier.
- Les Models: `User`, `Lobby`,`LobbySettings`, `Story`, `StoryElement`.
- Les Enums : `Page`, `PlaceType`, `AudioType`, `StoryElementType`, `TimerSetting`, `ErrorType`, `LogLevel`, 
  - `SocketEvent`: les strings des events de `Socket.io`.
  - `OpResult`: contient {data: any ,success: boolean, error: OpError} qui permet de faire remonter les erreurs et les résultats jusqu'au gestionnaire d'events `Socket.io`.
  - `OpError`: contient {type: ErrorType, logLevel: LogLevel, error: any} pour gérer les erreurs et les logs.
- La Fonction `processOp` qui permet de traiter les `OpResult` et de log en fonction de `OpError` et `LogLevel`.  
  


#### `/serveur/src/` : contient les fichiers sources du serveur.
la majeur partie des fonctions du serveur utilisent le systeme d'`OpResult`.
- `./sever.ts`: Fichier principal du serveur, initialisation de `Express.js`, du serveur et des events 
`Socket.io`, connexion à la base de données `PostgreSQL`.    
  

- `./db.ts`: contient les fonctions pour interagir avec la base de données en queries `PostgreSQL`, 
tel que `dbSelectLooby` ou `dbTransactionBegin`, etc.  
  

- `./socketHandlers/`: dossier contenant la gestion des events `Socket.io`.
  
  - `./socketService.ts`: Il définit :
    - Les fonctions pour envoyer des messages aux clients, 
      diffuser des messages à tous les clients dans une salle spécifique,
      et gérer les connexions et déconnexions des utilisateurs.
    - Les d'événements pour diverses actions, comme la création de lobbies, 
    le démarrage et la fin de jeux, la soumission et la récupération d'éléments d'histoire,
    la gestion des paramètres de lobby, etc.  
    - Gere l'attente (le loading) de certaines requêtes (Join, Create, Leave, StartGame, SubmitStoryElements, EndGame).
    - Gere les requêtes échouées, les renvoie avec les memes arguments et actualise la page au bout de 5 essais.
  - `./inactiveUsersHandler.ts`: gere les utilisateurs inactifs, les déconnecte et les supprime des lobbies.
  - `./lobbyHandlers/`: contient les gestionnaires d'événements pour les actions liées aux lobbies.
    - onCreateLobby, onJoinLobby, onLeaveLobby.
    - `./submitLobbySettings` pour les gestionnaires des paramètres de lobby.
  - `./gameHandlers/`: contient les gestionnaires d'événements pour les actions liées aux jeux.
    - onStartGame, onEndGame, onGetStory, onGetStoryAtPart, onNextPart, 
    onSubmitStoryElements, onUnSubmitStoryElements.
    - `./roundHandler` qui gere les rounds et les timers.
    - `./resetGames` en cas de crash du serveur, permet de relancer les rounds.  
      

#### `/client/src/`: contient les fichiers sources du client.
- `./App.tsx`: Fichier principal du client, contient le routage des pages.  
  

- `./LobbyContext.tsx`: Contexte partagé entre les composants React pour les données du lobby.  
  

- `./components/`: contient les composants React réutilisables :
  - `StoryElementComponent`: affiche un élément d'histoire (texte, image, audio, dessin).
  - `StoryUserComponent`: affiche tous les éléments d'histoire d'un utilisateur avec `StoryElementComponent`.
  - `StoryGameComponent`: affiche les elements d'histoire des precedents utilisateurs avec `StoryUserComponent`
  et permet d'ajouter des éléments.
  - `StoryResultsComponent`: affiche et joue les histoires créées, utilisateur par utilisateur.
  - `TimerComponent`: affiche un compte à rebours pour les rounds.
  - `DrawingComponent`: permet de dessiner et d'ajouter un dessin à l'histoire.
    

- `./pages/`: contient les pages React de l'application :
  - `JoinView`: permet de rejoindre ou de créer un lobby et d'accéder à `HowToPlayView`, `ContactView`.
  - `LobbyView`: permet de voir les paramètres du lobby, de changer les paramètres, de démarrer le jeu.
  - `GameView`: permet de jouer au jeu, d'ajouter des éléments à l'histoire dans un round.
  - `ResultsView`: permet de voir les histoires créées par les utilisateurs.
  - `HowToPlayView`: explique comment jouer à `Story Game`.
  - `ContactView`: affiche un formulaire de contact pour les commentaires et les suggestions.

- `utils/`: contient les fonctions utilitaires pour les composants React.
  -  `./socketService.ts`: définit les gestionnaires d'événements `Socket.io` pour la communication client-serveur.

## Déroulement des events :
### Connexion :
1. L'utilisateur se connecte à l'application web.
2. Le socketService cree un uuid unique pour l'utilisateur où le récupère dans le localStorage du navigateur.
3. Le client envoie la requête `GET_LOBBY` au serveur pour récupérer le lobby actuel de l'utilisateur.
4. Le serveur reçoit la requête, renvoie le lobby actuel de l'utilisateur, 
   - si l'utilisateur n'existe pas dans la BDD renvoie le Warning USER_NOT_FOUND.
   - si l'utilisateur n'est pas dans un lobby, ne renvoie rien.
   - s'il y a une erreur lors de la requête, elle est renvoyée au client.
5. Le client reçoit la réponse du serveur, met à jour le contexte du lobby, et redirige l'utilisateur vers la
page correspondante à l'état actuel du lobby.

### Création d'un Lobby :
1.  L'utilisateur dans la page `Join` crée un lobby en entrant un nom d'utilisateur sans mettre de code de lobby.
2. Le client envoie la requête `CREATE_LOBBY` au serveur avec le nom d'utilisateur et l'id de l'utilisateur.
3. Le serveur reçoit la requête, si l'utilisateur n'existe pas dans la BDD, insère l'utilisateur dans la BDD,
puis crée un lobby avec l'id de l'utilisateur comme hôte, et renvoie le lobby créé avec l'event `LOBBY_INFO`.
   - s'il y a une erreur lors de la requête, elle est renvoyée au client.
4. Le client reçoit la réponse du serveur, met à jour le contexte du lobby, et redirige l'utilisateur vers la 
page `Lobby`.
   - s'il reçoit une erreur, le socketService essaie de renvoyer la requête 5 fois, puis actualise la page.

### Rejoindre un Lobby :
1. L'utilisateur dans la page `Join` rejoint un lobby en entrant un nom d'utilisateur et un code de lobby.
2. Le client envoie la requête `JOIN_LOBBY` au serveur avec le nom d'utilisateur, l'id de l'utilisateur et le code de lobby.
3. Le serveur reçoit la requête, si l'utilisateur n'existe pas dans la BDD, insère l'utilisateur dans la BDD,
puis renvoie le lobby avec l'event `LOBBY_INFO`.
   - si le lobby n'existe pas dans la BDD, renvoie le Warning LOBBY_NOT_FOUND.
   - si le lobby est plein, renvoie le Warning LOBBY_MAX_PLAYERS_REACHED.
   - si le lobby est en cours de jeu, renvoie le Warning LOBBY_ALREADY_PLAYING.
4. Le client reçoit la réponse du serveur, met à jour le contexte du lobby, et redirige l'utilisateur vers la
page `Lobby`.
   - s'il reçoit un Warning, il affiche le message d'erreur sur la page `Join`.
   - s'il reçoit une erreur, le socketService essaie de renvoyer la requête 5 fois, puis actualise la page.

### Paramètres du Lobby :
1. L'utilisateur dans la page `Lobby` change les paramètres du lobby.
2. Le client envoie la requête `SUBMIT_{NOM_PARAMETRE}` au serveur avec la nouvelle valeur du paramètre.
3. Le serveur reçoit la requête, met à jour le lobby dans la BDD, et renvoie le lobby a tous les utilisateurs du lobby 
avec l'event `LOBBY_INFO`.
   - si l'utilisateur n'est pas l'hôte du lobby, renvoie le Warning USER_NOT_HOST.
   - s'il y a une erreur lors de la requête, elle est renvoyée au client.
4. Le client reçoit la réponse du serveur, met à jour le paramètre du lobby sur la page `Lobby`.
   - s'il reçoit un Warning, il remet le paramètre à sa valeur précédente.
   - s'il reçoit une erreur, le socketService essaie de renvoyer la requête 5 fois, puis actualise la page.

### Déroulement du Jeu:

#### Demarrer le Jeu :
1. L'utilisateur dans la page `Lobby` appuie sur le bouton `Start Game`.  
  

2. Le client envoie la requête `START_GAME` au serveur.  
  

3. Le serveur reçoit la requête et:
   1. Initialise les variables de jeu: 
        - userIndexOrder: contiens l'ordre de chaque utilisateur avec son id.
        - usersSubmitted: initialisé à 0.
   2. Fait appel au `roundHandler` pour démarrer un round et le timer.
   3. Le `roundHandler` initialise le round, round_start_at, round_end_at.
   4. Envoie le lobby mis à jour à tous les utilisateurs du lobby avec l'event `LOBBY_INFO`.
   - si l'utilisateur n'est pas l'hôte du lobby, renvoie le Warning USER_NOT_HOST.
   - s'il y a une erreur lors de la requête, elle est renvoyée au client.  
     
#### Déroulement d'un Round :    

4. Les clients reçoivent la réponse du serveur, mettent à jour le contexte du lobby, vérifient si le round à changer,
si oui, envoie la requête `GET_STORY` pour récupérer l'histoire actuelle.
    - s'il reçoit une erreur, le socketService essaie de renvoyer la requête 5 fois, puis actualise la page.
  

5. Le serveur reçoit la requête, renvoie l'histoire correspondant au round actuel et à l'utilisateur (en utilisant userIndexOrder) 
avec l'event `STORY`.
    - s'il y a une erreur lors de la requête, elle est renvoyée au client.
  

6. Les clients reçoivent l'histoire actuelle, et affichent les éléments d'histoire de l'utilisateur.
   - s'il reçoit une erreur, le socketService essaie de renvoyer la requête 5 fois, puis actualise la page.  
     

7. Les utilisateurs ajoutent des éléments à l'histoire dans le round en cours, et peuvent soumettre leurs
éléments avec l'event `SUBMIT_STORY_ELEMENTS`.
   - l'utilisateur peut choisir d'annuler la soumission avec l'event `UNSUBMIT_STORY_ELEMENTS` qui 
    lui permet de modifier, supprimer ou ajouter d'autres éléments à l'histoire. 
     

8. Le serveur reçoit les éléments d'histoires, les stocke dans la BDD, met l'utilisateur à ready, incrémente le
usersSubmitted, et verifie si tous les utilisateurs ont soumis.  
  

9. Après la fin du timer, ou si tous les utilisateurs ont soumis, le `roundHandler`:
   1. Arrête le timer.
   2. Met un element d'histoire `EMPTY` pour les utilisateurs qui n'ont pas réussi à soumettre.
   3. Incrémente le round et reinitialise le round_start_at, round_end_at.
   4. Envoie le lobby mis à jour à tous les utilisateurs du lobby avec l'event `LOBBY_INFO`.
   - si l'utilisateur n'est pas l'hôte du lobby, renvoie le Warning USER_NOT_HOST.
   - s'il y a une erreur lors de la requête, elle est renvoyée au client.
    

10. Les clients reçoivent la réponse du serveur, mettent à jour le contexte du lobby, vérifient si le round à changer,
si oui, envoie la requête `GET_STORY` pour récupérer l'histoire actuelle.
    - s'il reçoit une erreur, le socketService essaie de renvoyer la requête 5 fois, puis actualise la page.  
  

11. Le serveur reçoit la requête, renvoie l'histoire actuelle de l'utilisateur avec l'event `STORY`.
    - s'il y a une erreur lors de la requête, elle est renvoyée au client.

12. Les clients reçoivent l'histoire actuelle, et affichent les éléments d'histoire de l'utilisateur precedent.
   - s'il reçoit une erreur, le socketService essaie de renvoyer la requête 5 fois, puis actualise la page.

13. Les étapes 7 à 12 se répètent jusqu'à ce que le round final soit atteint.

#### Fin du Jeu :

14. Au round final, le `roundHandler` met le round à -1, currentStoryIndex à 0, currentUserIndex à 0,
et envoie le lobby mis à jour à tous les utilisateurs du lobby avec l'event `LOBBY_INFO`.
    - s'il y a une erreur lors de la requête, elle est renvoyée au client.
  

15. Les clients reçoivent la réponse du serveur, mettent à jour le contexte du lobby, et redirigent l'utilisateur vers la
page `Results`.
    - s'il reçoit une erreur, le socketService essaie de renvoyer la requête 5 fois, puis actualise la page.
  

16. Le client envoie la requête `GET_STORY_AT_PART` au serveur pour récupérer l'histoire et l'index de l'utilisateur courant.
  

17. Le serveur reçoit la requête, renvoie l'histoire actuelle et l'index de l'utilisateur avec l'event `STORY_AT_PART` et 
affiche les elements 
    - s'il y a une erreur lors de la requête, elle est renvoyée au client.

18. Les clients reçoivent l'histoire actuelle, et affichent les éléments d'histoire de l'utilisateur.
  

19. L'hôte du lobby peut appuyer sur `Next Story` pour passer à la partie de l'histoire de l'utilisateur suivant avec l'event `NEXT_PART`.
  

20. Le serveur reçoit la requête, renvoie l'index du prochain utilisateur dans l'histoire avec l'event `PART`.
    - s'il y a une erreur lors de la requête, elle est renvoyée au client.
    

21. Les clients reçoivent l'index du prochain utilisateur, et affichent les éléments d'histoire de l'utilisateur suivant 
    - s'il reçoit une erreur, le socketService essaie de renvoyer la requête 5 fois, puis actualise la page.
  

22. Les étapes 18 à 21 se répètent jusqu'à ce que les utilisateurs aient vu toutes les parties de l'histoire.  


23. L'hôte du lobby peut alors appuyer sur `End Game` pour terminer le jeu et renvoyer tous les utilisateurs à la page `Lobby`.  
  

24. Le serveur reçoit la requête, reinitialise le lobby (sauf les paramètres), et renvoie le lobby mis à jour à tous les utilisateurs du lobby avec l'event `LOBBY_INFO`.
    - s'il y a une erreur lors de la requête, elle est renvoyée au client.

25. Les clients reçoivent la réponse du serveur, mettent à jour le contexte du lobby, et redirigent l'utilisateur vers la
page `Lobby`.
    - s'il reçoit une erreur, le socketService essaie de renvoyer la requête 5 fois, puis actualise la page.
    

26. Les joueurs peuvent alors rejouer une partie ou quitter le lobby, après un bon moment passé ensemble.


### Déconnexions:
- Si un utilisateur se déconnecte en rafraîchissant la page, en fermant l'onglet, ou en quittant le site, le serveur
attend 10 secondes pour voir si l'utilisateur se reconnecte.
  - l'utilisateur est considéré comme inactif pendant le temps d'attente et il ne sera pas attendu pour la fin du round.
  - si l'utilisateur se reconnecte, il est reconsidéré comme actif et peut continuer à jouer.
  - si l'utilisateur ne se reconnecte pas, il est exclu complétement du lobby et le round continue sans lui.
  

- Si un utilisateur est exclu complétement du lobby en raison d'une déconnexion, ou en appuyant sur le bouton `Leave Lobby`,
  - le serveur met à jour le lobby en mettant un joueur `Disconnected x(` à la place de l'utilisateur, et envoie le lobby 
  mis à jour à tous les utilisateurs du lobby avec l'event `LOBBY_INFO`.
  - l'utilisateur exclu garde le droit de re-rejoindre le lobby, et de continuer à jouer tranquillement.

### Gestion des Erreurs:
- Les erreurs sont gérées par le système d'`OpResult` dans le serveur chaque demande a la BDD et chaque event `Socket.io`,
renvoie un `OpResult` qui contient {data: any, success: boolean, error: OpError} ce qui permet de faire remonter les erreurs
jusqu'au gestionnaire d'events qui vont les log et les renvoyer au client dans la majorité des cas.  
  
  
- Les erreurs de logLevel `Warning` sont renvoyées au client pour afficher un message d'erreur sur la page.  
  

- Les erreurs de logLevel `Error` sont gérées par le `socketService` du client qui va decider de renvoyer la requête
ou d'actualiser la page après 5 essais.
  
  
### Gestion des Requêtes Coté Client :
- La plupart des requêtes envoyées par le client attendent une réponse du serveur, ils ne peuvent renvoyer la même requête
qu'après avoir reçu une réponse du serveur.
    - La réponse du serveur peut être un event ou une erreur, si c'est une erreur de logLevel `Error` , le `socketService`
 (dans la majorité des cas) va renvoyer la requête après 5 essais, sinon il va actualiser la page.
   

- Certaines requêtes comme `Join`, `Create`, `Leave`, `StartGame`, `SubmitStoryElements`, `EndGame` sont marquées comme
requérant un loading, a l'envoie de la requête, un loading screen est affiché sur la page, et le client attend la réponse.

